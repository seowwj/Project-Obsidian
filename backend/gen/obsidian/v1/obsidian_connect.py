# -*- coding: utf-8 -*-
# Generated by https://github.com/connectrpc/connect-python.  DO NOT EDIT!
# source: obsidian/v1/obsidian.proto

from collections.abc import AsyncGenerator, AsyncIterator, Iterable, Iterator, Mapping
from typing import Protocol

from connectrpc.client import ConnectClient, ConnectClientSync
from connectrpc.code import Code
from connectrpc.errors import ConnectError
from connectrpc.interceptor import Interceptor, InterceptorSync
from connectrpc.method import IdempotencyLevel, MethodInfo
from connectrpc.request import Headers, RequestContext
from connectrpc.server import ConnectASGIApplication, ConnectWSGIApplication, Endpoint, EndpointSync
import obsidian.v1.obsidian_pb2 as obsidian_dot_v1_dot_obsidian__pb2


class ChatService(Protocol):
    def chat(self, request: obsidian_dot_v1_dot_obsidian__pb2.ChatRequest, ctx: RequestContext) -> AsyncIterator[obsidian_dot_v1_dot_obsidian__pb2.ChatResponse]:
        raise ConnectError(Code.UNIMPLEMENTED, "Not implemented")


class ChatServiceASGIApplication(ConnectASGIApplication[ChatService]):
    def __init__(self, service: ChatService | AsyncGenerator[ChatService], *, interceptors: Iterable[Interceptor]=(), read_max_bytes: int | None = None) -> None:
        super().__init__(
            service=service,
            endpoints=lambda svc: {
                "/obsidian.v1.ChatService/Chat": Endpoint.server_stream(
                    method=MethodInfo(
                        name="Chat",
                        service_name="obsidian.v1.ChatService",
                        input=obsidian_dot_v1_dot_obsidian__pb2.ChatRequest,
                        output=obsidian_dot_v1_dot_obsidian__pb2.ChatResponse,
                        idempotency_level=IdempotencyLevel.UNKNOWN,
                    ),
                    function=svc.chat,
                ),
            },
            interceptors=interceptors,
            read_max_bytes=read_max_bytes,
        )

    @property
    def path(self) -> str:
        """Returns the URL path to mount the application to when serving multiple applications."""
        return "/obsidian.v1.ChatService"


class ChatServiceClient(ConnectClient):
    def chat(
        self,
        request: obsidian_dot_v1_dot_obsidian__pb2.ChatRequest,
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
    ) -> AsyncIterator[obsidian_dot_v1_dot_obsidian__pb2.ChatResponse]:
        return self.execute_server_stream(
            request=request,
            method=MethodInfo(
                name="Chat",
                service_name="obsidian.v1.ChatService",
                input=obsidian_dot_v1_dot_obsidian__pb2.ChatRequest,
                output=obsidian_dot_v1_dot_obsidian__pb2.ChatResponse,
                idempotency_level=IdempotencyLevel.UNKNOWN,
            ),
            headers=headers,
            timeout_ms=timeout_ms,
        )



class SessionService(Protocol):
    async def list_sessions(self, request: obsidian_dot_v1_dot_obsidian__pb2.ListSessionsRequest, ctx: RequestContext) -> obsidian_dot_v1_dot_obsidian__pb2.ListSessionsResponse:
        raise ConnectError(Code.UNIMPLEMENTED, "Not implemented")

    async def create_session(self, request: obsidian_dot_v1_dot_obsidian__pb2.CreateSessionRequest, ctx: RequestContext) -> obsidian_dot_v1_dot_obsidian__pb2.CreateSessionResponse:
        raise ConnectError(Code.UNIMPLEMENTED, "Not implemented")

    async def delete_session(self, request: obsidian_dot_v1_dot_obsidian__pb2.DeleteSessionRequest, ctx: RequestContext) -> obsidian_dot_v1_dot_obsidian__pb2.DeleteSessionResponse:
        raise ConnectError(Code.UNIMPLEMENTED, "Not implemented")

    async def rename_session(self, request: obsidian_dot_v1_dot_obsidian__pb2.RenameSessionRequest, ctx: RequestContext) -> obsidian_dot_v1_dot_obsidian__pb2.RenameSessionResponse:
        raise ConnectError(Code.UNIMPLEMENTED, "Not implemented")


class SessionServiceASGIApplication(ConnectASGIApplication[SessionService]):
    def __init__(self, service: SessionService | AsyncGenerator[SessionService], *, interceptors: Iterable[Interceptor]=(), read_max_bytes: int | None = None) -> None:
        super().__init__(
            service=service,
            endpoints=lambda svc: {
                "/obsidian.v1.SessionService/ListSessions": Endpoint.unary(
                    method=MethodInfo(
                        name="ListSessions",
                        service_name="obsidian.v1.SessionService",
                        input=obsidian_dot_v1_dot_obsidian__pb2.ListSessionsRequest,
                        output=obsidian_dot_v1_dot_obsidian__pb2.ListSessionsResponse,
                        idempotency_level=IdempotencyLevel.UNKNOWN,
                    ),
                    function=svc.list_sessions,
                ),
                "/obsidian.v1.SessionService/CreateSession": Endpoint.unary(
                    method=MethodInfo(
                        name="CreateSession",
                        service_name="obsidian.v1.SessionService",
                        input=obsidian_dot_v1_dot_obsidian__pb2.CreateSessionRequest,
                        output=obsidian_dot_v1_dot_obsidian__pb2.CreateSessionResponse,
                        idempotency_level=IdempotencyLevel.UNKNOWN,
                    ),
                    function=svc.create_session,
                ),
                "/obsidian.v1.SessionService/DeleteSession": Endpoint.unary(
                    method=MethodInfo(
                        name="DeleteSession",
                        service_name="obsidian.v1.SessionService",
                        input=obsidian_dot_v1_dot_obsidian__pb2.DeleteSessionRequest,
                        output=obsidian_dot_v1_dot_obsidian__pb2.DeleteSessionResponse,
                        idempotency_level=IdempotencyLevel.UNKNOWN,
                    ),
                    function=svc.delete_session,
                ),
                "/obsidian.v1.SessionService/RenameSession": Endpoint.unary(
                    method=MethodInfo(
                        name="RenameSession",
                        service_name="obsidian.v1.SessionService",
                        input=obsidian_dot_v1_dot_obsidian__pb2.RenameSessionRequest,
                        output=obsidian_dot_v1_dot_obsidian__pb2.RenameSessionResponse,
                        idempotency_level=IdempotencyLevel.UNKNOWN,
                    ),
                    function=svc.rename_session,
                ),
            },
            interceptors=interceptors,
            read_max_bytes=read_max_bytes,
        )

    @property
    def path(self) -> str:
        """Returns the URL path to mount the application to when serving multiple applications."""
        return "/obsidian.v1.SessionService"


class SessionServiceClient(ConnectClient):
    async def list_sessions(
        self,
        request: obsidian_dot_v1_dot_obsidian__pb2.ListSessionsRequest,
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
    ) -> obsidian_dot_v1_dot_obsidian__pb2.ListSessionsResponse:
        return await self.execute_unary(
            request=request,
            method=MethodInfo(
                name="ListSessions",
                service_name="obsidian.v1.SessionService",
                input=obsidian_dot_v1_dot_obsidian__pb2.ListSessionsRequest,
                output=obsidian_dot_v1_dot_obsidian__pb2.ListSessionsResponse,
                idempotency_level=IdempotencyLevel.UNKNOWN,
            ),
            headers=headers,
            timeout_ms=timeout_ms,
        )

    async def create_session(
        self,
        request: obsidian_dot_v1_dot_obsidian__pb2.CreateSessionRequest,
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
    ) -> obsidian_dot_v1_dot_obsidian__pb2.CreateSessionResponse:
        return await self.execute_unary(
            request=request,
            method=MethodInfo(
                name="CreateSession",
                service_name="obsidian.v1.SessionService",
                input=obsidian_dot_v1_dot_obsidian__pb2.CreateSessionRequest,
                output=obsidian_dot_v1_dot_obsidian__pb2.CreateSessionResponse,
                idempotency_level=IdempotencyLevel.UNKNOWN,
            ),
            headers=headers,
            timeout_ms=timeout_ms,
        )

    async def delete_session(
        self,
        request: obsidian_dot_v1_dot_obsidian__pb2.DeleteSessionRequest,
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
    ) -> obsidian_dot_v1_dot_obsidian__pb2.DeleteSessionResponse:
        return await self.execute_unary(
            request=request,
            method=MethodInfo(
                name="DeleteSession",
                service_name="obsidian.v1.SessionService",
                input=obsidian_dot_v1_dot_obsidian__pb2.DeleteSessionRequest,
                output=obsidian_dot_v1_dot_obsidian__pb2.DeleteSessionResponse,
                idempotency_level=IdempotencyLevel.UNKNOWN,
            ),
            headers=headers,
            timeout_ms=timeout_ms,
        )

    async def rename_session(
        self,
        request: obsidian_dot_v1_dot_obsidian__pb2.RenameSessionRequest,
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
    ) -> obsidian_dot_v1_dot_obsidian__pb2.RenameSessionResponse:
        return await self.execute_unary(
            request=request,
            method=MethodInfo(
                name="RenameSession",
                service_name="obsidian.v1.SessionService",
                input=obsidian_dot_v1_dot_obsidian__pb2.RenameSessionRequest,
                output=obsidian_dot_v1_dot_obsidian__pb2.RenameSessionResponse,
                idempotency_level=IdempotencyLevel.UNKNOWN,
            ),
            headers=headers,
            timeout_ms=timeout_ms,
        )



class HistoryService(Protocol):
    async def get_history(self, request: obsidian_dot_v1_dot_obsidian__pb2.GetHistoryRequest, ctx: RequestContext) -> obsidian_dot_v1_dot_obsidian__pb2.GetHistoryResponse:
        raise ConnectError(Code.UNIMPLEMENTED, "Not implemented")


class HistoryServiceASGIApplication(ConnectASGIApplication[HistoryService]):
    def __init__(self, service: HistoryService | AsyncGenerator[HistoryService], *, interceptors: Iterable[Interceptor]=(), read_max_bytes: int | None = None) -> None:
        super().__init__(
            service=service,
            endpoints=lambda svc: {
                "/obsidian.v1.HistoryService/GetHistory": Endpoint.unary(
                    method=MethodInfo(
                        name="GetHistory",
                        service_name="obsidian.v1.HistoryService",
                        input=obsidian_dot_v1_dot_obsidian__pb2.GetHistoryRequest,
                        output=obsidian_dot_v1_dot_obsidian__pb2.GetHistoryResponse,
                        idempotency_level=IdempotencyLevel.UNKNOWN,
                    ),
                    function=svc.get_history,
                ),
            },
            interceptors=interceptors,
            read_max_bytes=read_max_bytes,
        )

    @property
    def path(self) -> str:
        """Returns the URL path to mount the application to when serving multiple applications."""
        return "/obsidian.v1.HistoryService"


class HistoryServiceClient(ConnectClient):
    async def get_history(
        self,
        request: obsidian_dot_v1_dot_obsidian__pb2.GetHistoryRequest,
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
    ) -> obsidian_dot_v1_dot_obsidian__pb2.GetHistoryResponse:
        return await self.execute_unary(
            request=request,
            method=MethodInfo(
                name="GetHistory",
                service_name="obsidian.v1.HistoryService",
                input=obsidian_dot_v1_dot_obsidian__pb2.GetHistoryRequest,
                output=obsidian_dot_v1_dot_obsidian__pb2.GetHistoryResponse,
                idempotency_level=IdempotencyLevel.UNKNOWN,
            ),
            headers=headers,
            timeout_ms=timeout_ms,
        )



class HealthService(Protocol):
    async def check(self, request: obsidian_dot_v1_dot_obsidian__pb2.HealthCheckRequest, ctx: RequestContext) -> obsidian_dot_v1_dot_obsidian__pb2.HealthCheckResponse:
        raise ConnectError(Code.UNIMPLEMENTED, "Not implemented")


class HealthServiceASGIApplication(ConnectASGIApplication[HealthService]):
    def __init__(self, service: HealthService | AsyncGenerator[HealthService], *, interceptors: Iterable[Interceptor]=(), read_max_bytes: int | None = None) -> None:
        super().__init__(
            service=service,
            endpoints=lambda svc: {
                "/obsidian.v1.HealthService/Check": Endpoint.unary(
                    method=MethodInfo(
                        name="Check",
                        service_name="obsidian.v1.HealthService",
                        input=obsidian_dot_v1_dot_obsidian__pb2.HealthCheckRequest,
                        output=obsidian_dot_v1_dot_obsidian__pb2.HealthCheckResponse,
                        idempotency_level=IdempotencyLevel.UNKNOWN,
                    ),
                    function=svc.check,
                ),
            },
            interceptors=interceptors,
            read_max_bytes=read_max_bytes,
        )

    @property
    def path(self) -> str:
        """Returns the URL path to mount the application to when serving multiple applications."""
        return "/obsidian.v1.HealthService"


class HealthServiceClient(ConnectClient):
    async def check(
        self,
        request: obsidian_dot_v1_dot_obsidian__pb2.HealthCheckRequest,
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
    ) -> obsidian_dot_v1_dot_obsidian__pb2.HealthCheckResponse:
        return await self.execute_unary(
            request=request,
            method=MethodInfo(
                name="Check",
                service_name="obsidian.v1.HealthService",
                input=obsidian_dot_v1_dot_obsidian__pb2.HealthCheckRequest,
                output=obsidian_dot_v1_dot_obsidian__pb2.HealthCheckResponse,
                idempotency_level=IdempotencyLevel.UNKNOWN,
            ),
            headers=headers,
            timeout_ms=timeout_ms,
        )


class ChatServiceSync(Protocol):
    def chat(self, request: obsidian_dot_v1_dot_obsidian__pb2.ChatRequest, ctx: RequestContext) -> Iterator[obsidian_dot_v1_dot_obsidian__pb2.ChatResponse]:
        raise ConnectError(Code.UNIMPLEMENTED, "Not implemented")


class ChatServiceWSGIApplication(ConnectWSGIApplication):
    def __init__(self, service: ChatServiceSync, interceptors: Iterable[InterceptorSync]=(), read_max_bytes: int | None = None) -> None:
        super().__init__(
            endpoints={
                "/obsidian.v1.ChatService/Chat": EndpointSync.server_stream(
                    method=MethodInfo(
                        name="Chat",
                        service_name="obsidian.v1.ChatService",
                        input=obsidian_dot_v1_dot_obsidian__pb2.ChatRequest,
                        output=obsidian_dot_v1_dot_obsidian__pb2.ChatResponse,
                        idempotency_level=IdempotencyLevel.UNKNOWN,
                    ),
                    function=service.chat,
                ),
            },
            interceptors=interceptors,
            read_max_bytes=read_max_bytes,
        )

    @property
    def path(self) -> str:
        """Returns the URL path to mount the application to when serving multiple applications."""
        return "/obsidian.v1.ChatService"


class ChatServiceClientSync(ConnectClientSync):
    def chat(
        self,
        request: obsidian_dot_v1_dot_obsidian__pb2.ChatRequest,
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
    ) -> Iterator[obsidian_dot_v1_dot_obsidian__pb2.ChatResponse]:
        return self.execute_server_stream(
            request=request,
            method=MethodInfo(
                name="Chat",
                service_name="obsidian.v1.ChatService",
                input=obsidian_dot_v1_dot_obsidian__pb2.ChatRequest,
                output=obsidian_dot_v1_dot_obsidian__pb2.ChatResponse,
                idempotency_level=IdempotencyLevel.UNKNOWN,
            ),
            headers=headers,
            timeout_ms=timeout_ms,
        )

class SessionServiceSync(Protocol):
    def list_sessions(self, request: obsidian_dot_v1_dot_obsidian__pb2.ListSessionsRequest, ctx: RequestContext) -> obsidian_dot_v1_dot_obsidian__pb2.ListSessionsResponse:
        raise ConnectError(Code.UNIMPLEMENTED, "Not implemented")
    def create_session(self, request: obsidian_dot_v1_dot_obsidian__pb2.CreateSessionRequest, ctx: RequestContext) -> obsidian_dot_v1_dot_obsidian__pb2.CreateSessionResponse:
        raise ConnectError(Code.UNIMPLEMENTED, "Not implemented")
    def delete_session(self, request: obsidian_dot_v1_dot_obsidian__pb2.DeleteSessionRequest, ctx: RequestContext) -> obsidian_dot_v1_dot_obsidian__pb2.DeleteSessionResponse:
        raise ConnectError(Code.UNIMPLEMENTED, "Not implemented")
    def rename_session(self, request: obsidian_dot_v1_dot_obsidian__pb2.RenameSessionRequest, ctx: RequestContext) -> obsidian_dot_v1_dot_obsidian__pb2.RenameSessionResponse:
        raise ConnectError(Code.UNIMPLEMENTED, "Not implemented")


class SessionServiceWSGIApplication(ConnectWSGIApplication):
    def __init__(self, service: SessionServiceSync, interceptors: Iterable[InterceptorSync]=(), read_max_bytes: int | None = None) -> None:
        super().__init__(
            endpoints={
                "/obsidian.v1.SessionService/ListSessions": EndpointSync.unary(
                    method=MethodInfo(
                        name="ListSessions",
                        service_name="obsidian.v1.SessionService",
                        input=obsidian_dot_v1_dot_obsidian__pb2.ListSessionsRequest,
                        output=obsidian_dot_v1_dot_obsidian__pb2.ListSessionsResponse,
                        idempotency_level=IdempotencyLevel.UNKNOWN,
                    ),
                    function=service.list_sessions,
                ),
                "/obsidian.v1.SessionService/CreateSession": EndpointSync.unary(
                    method=MethodInfo(
                        name="CreateSession",
                        service_name="obsidian.v1.SessionService",
                        input=obsidian_dot_v1_dot_obsidian__pb2.CreateSessionRequest,
                        output=obsidian_dot_v1_dot_obsidian__pb2.CreateSessionResponse,
                        idempotency_level=IdempotencyLevel.UNKNOWN,
                    ),
                    function=service.create_session,
                ),
                "/obsidian.v1.SessionService/DeleteSession": EndpointSync.unary(
                    method=MethodInfo(
                        name="DeleteSession",
                        service_name="obsidian.v1.SessionService",
                        input=obsidian_dot_v1_dot_obsidian__pb2.DeleteSessionRequest,
                        output=obsidian_dot_v1_dot_obsidian__pb2.DeleteSessionResponse,
                        idempotency_level=IdempotencyLevel.UNKNOWN,
                    ),
                    function=service.delete_session,
                ),
                "/obsidian.v1.SessionService/RenameSession": EndpointSync.unary(
                    method=MethodInfo(
                        name="RenameSession",
                        service_name="obsidian.v1.SessionService",
                        input=obsidian_dot_v1_dot_obsidian__pb2.RenameSessionRequest,
                        output=obsidian_dot_v1_dot_obsidian__pb2.RenameSessionResponse,
                        idempotency_level=IdempotencyLevel.UNKNOWN,
                    ),
                    function=service.rename_session,
                ),
            },
            interceptors=interceptors,
            read_max_bytes=read_max_bytes,
        )

    @property
    def path(self) -> str:
        """Returns the URL path to mount the application to when serving multiple applications."""
        return "/obsidian.v1.SessionService"


class SessionServiceClientSync(ConnectClientSync):
    def list_sessions(
        self,
        request: obsidian_dot_v1_dot_obsidian__pb2.ListSessionsRequest,
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
    ) -> obsidian_dot_v1_dot_obsidian__pb2.ListSessionsResponse:
        return self.execute_unary(
            request=request,
            method=MethodInfo(
                name="ListSessions",
                service_name="obsidian.v1.SessionService",
                input=obsidian_dot_v1_dot_obsidian__pb2.ListSessionsRequest,
                output=obsidian_dot_v1_dot_obsidian__pb2.ListSessionsResponse,
                idempotency_level=IdempotencyLevel.UNKNOWN,
            ),
            headers=headers,
            timeout_ms=timeout_ms,
        )

    def create_session(
        self,
        request: obsidian_dot_v1_dot_obsidian__pb2.CreateSessionRequest,
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
    ) -> obsidian_dot_v1_dot_obsidian__pb2.CreateSessionResponse:
        return self.execute_unary(
            request=request,
            method=MethodInfo(
                name="CreateSession",
                service_name="obsidian.v1.SessionService",
                input=obsidian_dot_v1_dot_obsidian__pb2.CreateSessionRequest,
                output=obsidian_dot_v1_dot_obsidian__pb2.CreateSessionResponse,
                idempotency_level=IdempotencyLevel.UNKNOWN,
            ),
            headers=headers,
            timeout_ms=timeout_ms,
        )

    def delete_session(
        self,
        request: obsidian_dot_v1_dot_obsidian__pb2.DeleteSessionRequest,
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
    ) -> obsidian_dot_v1_dot_obsidian__pb2.DeleteSessionResponse:
        return self.execute_unary(
            request=request,
            method=MethodInfo(
                name="DeleteSession",
                service_name="obsidian.v1.SessionService",
                input=obsidian_dot_v1_dot_obsidian__pb2.DeleteSessionRequest,
                output=obsidian_dot_v1_dot_obsidian__pb2.DeleteSessionResponse,
                idempotency_level=IdempotencyLevel.UNKNOWN,
            ),
            headers=headers,
            timeout_ms=timeout_ms,
        )

    def rename_session(
        self,
        request: obsidian_dot_v1_dot_obsidian__pb2.RenameSessionRequest,
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
    ) -> obsidian_dot_v1_dot_obsidian__pb2.RenameSessionResponse:
        return self.execute_unary(
            request=request,
            method=MethodInfo(
                name="RenameSession",
                service_name="obsidian.v1.SessionService",
                input=obsidian_dot_v1_dot_obsidian__pb2.RenameSessionRequest,
                output=obsidian_dot_v1_dot_obsidian__pb2.RenameSessionResponse,
                idempotency_level=IdempotencyLevel.UNKNOWN,
            ),
            headers=headers,
            timeout_ms=timeout_ms,
        )

class HistoryServiceSync(Protocol):
    def get_history(self, request: obsidian_dot_v1_dot_obsidian__pb2.GetHistoryRequest, ctx: RequestContext) -> obsidian_dot_v1_dot_obsidian__pb2.GetHistoryResponse:
        raise ConnectError(Code.UNIMPLEMENTED, "Not implemented")


class HistoryServiceWSGIApplication(ConnectWSGIApplication):
    def __init__(self, service: HistoryServiceSync, interceptors: Iterable[InterceptorSync]=(), read_max_bytes: int | None = None) -> None:
        super().__init__(
            endpoints={
                "/obsidian.v1.HistoryService/GetHistory": EndpointSync.unary(
                    method=MethodInfo(
                        name="GetHistory",
                        service_name="obsidian.v1.HistoryService",
                        input=obsidian_dot_v1_dot_obsidian__pb2.GetHistoryRequest,
                        output=obsidian_dot_v1_dot_obsidian__pb2.GetHistoryResponse,
                        idempotency_level=IdempotencyLevel.UNKNOWN,
                    ),
                    function=service.get_history,
                ),
            },
            interceptors=interceptors,
            read_max_bytes=read_max_bytes,
        )

    @property
    def path(self) -> str:
        """Returns the URL path to mount the application to when serving multiple applications."""
        return "/obsidian.v1.HistoryService"


class HistoryServiceClientSync(ConnectClientSync):
    def get_history(
        self,
        request: obsidian_dot_v1_dot_obsidian__pb2.GetHistoryRequest,
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
    ) -> obsidian_dot_v1_dot_obsidian__pb2.GetHistoryResponse:
        return self.execute_unary(
            request=request,
            method=MethodInfo(
                name="GetHistory",
                service_name="obsidian.v1.HistoryService",
                input=obsidian_dot_v1_dot_obsidian__pb2.GetHistoryRequest,
                output=obsidian_dot_v1_dot_obsidian__pb2.GetHistoryResponse,
                idempotency_level=IdempotencyLevel.UNKNOWN,
            ),
            headers=headers,
            timeout_ms=timeout_ms,
        )

class HealthServiceSync(Protocol):
    def check(self, request: obsidian_dot_v1_dot_obsidian__pb2.HealthCheckRequest, ctx: RequestContext) -> obsidian_dot_v1_dot_obsidian__pb2.HealthCheckResponse:
        raise ConnectError(Code.UNIMPLEMENTED, "Not implemented")


class HealthServiceWSGIApplication(ConnectWSGIApplication):
    def __init__(self, service: HealthServiceSync, interceptors: Iterable[InterceptorSync]=(), read_max_bytes: int | None = None) -> None:
        super().__init__(
            endpoints={
                "/obsidian.v1.HealthService/Check": EndpointSync.unary(
                    method=MethodInfo(
                        name="Check",
                        service_name="obsidian.v1.HealthService",
                        input=obsidian_dot_v1_dot_obsidian__pb2.HealthCheckRequest,
                        output=obsidian_dot_v1_dot_obsidian__pb2.HealthCheckResponse,
                        idempotency_level=IdempotencyLevel.UNKNOWN,
                    ),
                    function=service.check,
                ),
            },
            interceptors=interceptors,
            read_max_bytes=read_max_bytes,
        )

    @property
    def path(self) -> str:
        """Returns the URL path to mount the application to when serving multiple applications."""
        return "/obsidian.v1.HealthService"


class HealthServiceClientSync(ConnectClientSync):
    def check(
        self,
        request: obsidian_dot_v1_dot_obsidian__pb2.HealthCheckRequest,
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
    ) -> obsidian_dot_v1_dot_obsidian__pb2.HealthCheckResponse:
        return self.execute_unary(
            request=request,
            method=MethodInfo(
                name="Check",
                service_name="obsidian.v1.HealthService",
                input=obsidian_dot_v1_dot_obsidian__pb2.HealthCheckRequest,
                output=obsidian_dot_v1_dot_obsidian__pb2.HealthCheckResponse,
                idempotency_level=IdempotencyLevel.UNKNOWN,
            ),
            headers=headers,
            timeout_ms=timeout_ms,
        )
